# Related work

## Algorithm Basics

Algorithm analysis is the backbone of Pathfinder there are very few dedicated softwares for benchmarking and algorithm analysis they often take the form of libraries for a language or there is a built in way to implement benchmarks in a code base an example being Rust and Cargo cargo has specific command to run benchmarks for a rust program although you have to manually write the benchmarks for your program. In things like game engine they give the performance of something while it's running but it doesn't give a summary or an overview of it's performance in different circumstances and input only what's currently running. This is good for debugging and optimizing a game or program as whole but it doesn't target pathfinding specifically only the program as a whole and it also doesn't run any experiments to see how it performs in different situations the user has to set that up themselves.

### Big-O Notation

Big-O notation is one of the most common ways to represent the complexity of an algorithm. It represents the most amount of steps given an input size [@BIGO]. It's also important to understand the complexity of the problem an algorithm is trying to solve. For example a Djikstra time complexity when trying to find the shortest path is **O(N^2)** this is because is mentioned before dijkstra will find every possible path from a starting point to another valid point[@WCBC]. This can often be estimated through looking at actual source code and analyzing the source code to come up with a notation. 

Another way is to run doubling experiments where you run the algorithm and double the input size and measure the change in run time[@AlgorithmAnalysis]. Which can help infer what the running time complexity allowing a researcher or developer to get an estimate for the overall time complexity of a program.

- **Run Time:** The amount of time it takes for a program to halt.

- **Running Time:** The amount of computational steps a program takes to get a solution

This is also a common benchmarking technique for software and performance as when the large the program gets the more unfeasible directly analyzing source code in a heuristic manor. Do to this while Pathfinder will check the performance of algorithms through a series of doubling experiments as it doesn't rely on known knowledge to give a result. This also allows for there to be deeper analysis on performance on different systems and hardware. Allowing developers to make more informed decisions on if a algorithm is worth using at smaller input sizes or if at a larger input size should it be switched to something else.

Research in pathfinding algorithms has produced a variety of approaches, each with distinct strengths and limitations. Foundational algorithms such as A* [@AStarSearch] and Dijkstra’s algorithm [@DIJKSTRA] remain widely used due to their reliability and efficiency in static environments. Numerous variants and heuristic-based methods have been proposed to address specific challenges, including dynamic environments and multi-agent scenarios.

## Heuristic Based Search

While something like A* uses heuristics in estimating a shortest path and chosing which node to search first depending how close it is to the estimated path. You can go even further with this with things like navigation meshes (NavMesh) [@BRANDSANDYTHESIS] and probabilistic roadmaps are commonly used in robotics and game development to represent walkable areas and facilitate efficient path computation. While these methods reduce search complexity, they often require substantial pre-computation and are less effective in highly dynamic or procedurally generated environments.

## Related Tools

### Vizualizers and Debuggers

#### Pathfinding Vizualizer

Visualization and benchmarking tools, such as the Pathfinding Visualizer by Clément Mihailescu [@ClémentMihailescu2016], provide interactive platforms for understanding algorithm behavior and seems primarily to be an education tool to help explain how known algorithms function. However, these tools often lack comprehensive benchmarking features and extensibility for custom algorithm development. Academic projects and open-source platforms have attempted to fill this gap, but many remain limited in scope or usability.

#### PFAlgoViz

There is also the PFAlgoViz by Karan Batta which similar to the previous program provides visualization for pathfinding algorithm while also allowing the implementation of modified or custom algorithms [@PFAlgo]. The purpose of this tool is to aid in debugging by giving an in-depth visualization of what the algorithm is doing and allowing a user to visually observe it's behavior. It also has built in error checking and the ability for breakpoint analysis allowing it to debug only sections of the code as defined by the user [@PFAlgo]. What this tool doesn't address is once again bench marking and algorithm analysis. This tool is great for understanding what a program is doing but doesn't give a defined metric of evaluating an algorithms performance in it's accuracy, time complexity and memory usage. This tool is great for getting a step by step account of what an algorithm is actually doing but it's not nor is it trying to be used as benchmarking or direct comparisons between algorithms.

### Path Planners in Robotics

#### Path Planner

PathPlanner is a path generation and routine design tool designed for FRC robotics by Team 3015. It provides an environment for creating and executing robot pathing[@PPlanner]. PathPlanner includes real-time path previewing and allows users to create “event markers” along a path, which can trigger specified code or commands to execute at those points. It also supports the construction of modular autonomous routines composed of multiple paths, with automatic file management and saving. PathPlanner also provides a vendor library for path generation and implementing custom controllers. While PathPlanner is a powerful tool for robotics within a competition setting, its purpose is focused on motion generation and autonomous behavior rather than benchmarking or comparative algorithm analysis. As such, it does not provide controlled experimental facilities or metrics for evaluating algorithm performance.

#### Choreo

Choreo is a path-optimization tool also designed for FRC robotics that generates mathematically optimal paths through user-defined waypoints while respecting environmental constraints [@Choreo]. Unlike a simple path-drawing tool, Choreo produces physically feasible paths for a robot to follow allowing for smoother execution of preplanned paths by a robot. Users are able to define paths using ordered points. Choreo provides an interactive UI, visualization, and tools for adjusting the environment and it's constraints,  and reassigning waypoint. These features enable detailed control over path structure while maintaining a user-friendly interface. While Choreo is great at optimizing path for real world robots with physical constraints its focus is on generating constraint-aware paths rather than benchmarking or comparative analysis. Thus, like PathPlanner, it serves practical robotics applications rather than algorithmic analysis.

## Game Engines and multimedia Libraries

Game engines such as Unreal, Unity, and Godot [@HH2022] are frequently employed as testbeds for pathfinding research. These engines offer powerful visualization and benchmarking capabilities but are not specifically designed for algorithmic analysis, resulting in a steep learning curve and potential overhead for researchers focused on algorithm development.

### Godot

Godot specifically implementing A* for 2D and 3D environments as well as the ability to create and generate navigation meshes for a game. While Godot does have benchmarking capabilities at is it monitors memory usage and performance when running a program. It also in terms of pathfinding and navigation it counts the numbers of agents, maps and polygons[@GodotDocs]. However it does not specifically benchmark the the algorithms in use nor does it run any doubling experiments it simply gives observable metrics and the state of the environment and the amount of objects within the environment.

### Multimedia Libraries

Lightweight multimedia frameworks like SDL[@SDLSITE], provide low-level access to graphics and input handling, enabling the creation of custom visualization tools. These frameworks offer greater control and efficiency compared to full-featured engines but require more development effort to implement benchmarking and analysis features. While also not having any built in tools for benchmarking programs.

## This Tool

Despite the breadth of existing solutions, there remains a need for dedicated, extensible tools that support both visualization and benchmarking of pathfinding algorithms in controlled environments. The tool presented in this work addresses these gaps by enabling user-defined map creation, algorithm implementation, and systematic performance analysis, thereby facilitating research and development in pathfinding.
