# Introduction

**Feedback**
It would be better if you started with a gentle intro to or mention of path finding in the first paragraph, and then get into what your project is about in the second paragraph or in the middle of the first paragraph, instead of jumping directly into it. It will help with clarity.

- Don't use future tense.
- Define all jargon (NavMesh, AI, benchmarking) when you first mention it.
- It is supposed to be a scientific paper. Your writing so far is too informal.
- Every claim you make needs to be cited.

- "2.2 Current State of the Art"( I would go a little more in depth)
- "2.3 Goals of the Project"(expand more on this)
- "2.4.1 Accuracy"(this should be most important , more clarification and explanation would help)

**Feedback**

## What is PathFinding?

Pathfinding is a computational process that determines an optimal route between two or more points within a defined environment. This concept is widely utilized across various industries, including navigation systems (e.g., GPS applications such as Google Maps), video game development for controlling non-playable characters (NPCs), and artificial intelligence (AI) for decision-making tasks. The primary objective of pathfinding algorithms is to identify the most efficient path, often minimizing distance, cost, or other relevant metrics, depending on the application context.

When evaluating pathfinding algorithms, both the choice of algorithm and the method of environmental representation are critical. In three-dimensional environments, such as those found in modern video games, navigation meshes (NavMesh) are commonly employed to delineate walkable areas. This project focuses on grid-based pathfinding, wherein the environment is modeled as a graph composed of nodes representing coordinates, obstacles, starting points, and goals. In grid-based systems, movement costs are typically uniform, whereas real-world applications may incorporate variable costs, such as fuel consumption or terrain difficulty, to reflect practical constraints. 

### A* Algorithm

![Depth First Tree @DepthFig](images/256px-Depth-first-tree.svg.png)

The A* (A-Star) algorithm is a widely recognized method for determining the shortest path between a designated start and goal within a graph. It operates by estimating the total cost of a path and prioritizing nodes based on this estimate. Fundamentally, A* extends the principles of depth-first search by evaluating neighboring nodes and assigning heuristic values that reflect the estimated cost to reach the goal. The algorithm selects the node with the lowest estimated cost for exploration, thereby optimizing the search process [@AStarSearch].

### Dijkstra Algorithm

Dijkstra's algorithm is another foundational approach in pathfinding, distinguished by its ability to compute the shortest paths from a single source to all other nodes within a graph. This property makes it particularly suitable for static environments where precomputation of paths is feasible. Dijkstra's algorithm maintains a set of unvisited nodes, each initialized with an infinite cost, and iteratively updates these costs as shorter paths are discovered. Upon completion, the algorithm yields the shortest path to every accessible node from the starting point [@DIJKSTRA].

### Weighted Grids

There are also weighted grids which have different values depending on a coordinate. In a normal grid moving one space over can simply be represented by 1 no matter where it is on the grid. Weighted grids differ as moving one space over may have a cost of 2 or 3 or any number depending on how the weighted grid is set up. There are also situations where there’s a dynamic environment where the map is always changing or the location the algorithm is trying to navigate is always changing thinking of something like self-driving car or a Roomba. These things normally have a set path they follow but need to be able to react to changes in the environment, so they don’t crash or in a more minor case a Roomba runs into someone’s leg. In this situation just using one algorithm doesn't work it needs to be able to react to a changing environment. Then there's also situations with multiple agents where they need to avoid colliding with each other but aim to achieve the same goal.

### Issues with Pathfinding

Pathfinding at its basic form is a very simple problem however it very quickly becomes computationally expensive. For example while getting a path between two points is simple on it's own what if you start adding more points that need to be visited in the mean time. What if you then need to return to the original starting point. This then quickly becomes a traveling salesmen problem which for a large amount of instances can be computed it is computationally expensive and inefficient. This leads to many uses of pathfinding algorithms being modified using different algorithms depending on the use or relying on a large amount of precomputed paths and possible paths. 

#### Probabilistic Maps

![Probabilistic Map Figure @s22228983](images/PM-Figure.jpg)

Another way information can be represent is a probabilistic map. Where a map is generated by take multiple different nodes placing it someone where on the map. It then will check if the node is within an obstacle space if it isn't it keeps and attempts to connect to other viable nodes. It does this by finding a path through another path-finding algorithm like Dijkstra or A* Usually using Dijkstra due to its nature of finding multiple paths to different nodes making it more ideal for generating a map. it then checks if that line collides with an Obstacle at any point. It does this multiple times until it has a comprehensive map of nodes with paths connecting each one to each other without colliding with an obstacle. This allows every possible movement path to already been calculated and you use another path-finding algorithm on top of that to know which nodes to go to get to a specified destination.

#### Navigation Mesh

![Navigation Map Figure @BRANDSANDYTHESIS](images/nav-mesh-figure.jpg)

A navigation mesh (NavMesh) is a polygonal representation of walkable regions in a two-dimensional or three-dimensional environment [@BRANDSANDYTHESIS]. Instead of using grid cells a Navmesh represents walkable space into polygons in which a agent can't navigate unobstructed. It will often use a pathfinding algorithm such as A* to run between nodes that represent one of the polygons. These are often in used in videogames as there reduce search complexity and videogames often allow for precomputation for prebuilt maps allowing for less computation when running[@BRANDSANDYTHESIS].


#### Scope of This Tool

This project focuses exclusively on unweighted, two-dimensional grid environments. Such grids provide a simple, controlled experimental setting and avoid the substantial precomputation required for probabilistic roadmaps and navigation meshes. Although limited in representational power, this choice facilitates clear visualization and benchmarking, making the tool suitable for algorithmic analysis.

## Project Overview

This project presents a tool designed for the development visualization and performance analysis of pathfinding algorithms algorithms operating on two-dimensional, grid-based environments. The tool allows users to create, edit, generate and save maps made from cells representing obstacles, open space, start positions and goal positions. Since Pathmaker allows the creation and editing of maps users can design specific test environments to evaluate algorithm behavior under varying circumstances. 

The program analyzes the results through benchmarking by recording metrics such as initial distance from the goal measured in manhattan distance meaning know diagonal movement, steps taken to reach the goal, computational steps required for a solution, and memory usage. It then stores this information and displays it for analysis. The hope for this project is that it makes testing and analyzing path-finding algorithms easier and to have a dedicated tool to that purpose instead of using a secondary feature of something like a game engine or having to make your own testing environment.

The tool also as the capability to allow for the implementation of user created algorithms. This is support algorithm development and research. Allowing for testing and visualization without requiring integration into a larger software. Pathmaker functions as a research environment allowing for controlled experimentation with pathfinding algorithms.

## Implementation Details

### Rust

The software is implemented using the Rust programming language. Rust is a statically typed, compiled language that emphasizes memory safety, zero-cost abstractions, and concurrency through a strict ownership model[@RustByExampleBeginner]. On top of Rust’s package manager providing an integrated build system and dependency manager, enabling modular development and reliable project configuration.

### SDL2

The graphical interface and input handling rely on the Simple DirectMedia Layer 2 (SDL2), a low-level multimedia library originally implemented in the C programming language. The reason for using SDL is because of it cross-platform capability on top of it's window creation, event and input handling, and rendering. This makes it suitable for lightweight visualization tools and games[@SDLSITE]. It giving low level access to inputs and graphics offers more precise control then something like a full featured game engine allowing analysis to be more accurate due to less overhead.

## Current State of the Art

### Visualizers

![Visualizer-Figure @ClémentMihailescu2016](images/Vizualiser-Figure.jpg)

Currently there are things like path-finding visualizers that you can find online these are mostly for education purposes and given a visualization on how these algorithms actually work and find the path. These often don't have any benchmarking capability and if they do it's simply tracking time to find path. They are also often very finnicky and unresponsive but that is a more of a result as a lot of them just being fun side projects of someone’s and not being a professionally made tool. 

### Game Engines

Game Engines like Unreal, Godot, Unity along with games created in those engines are often used as testbeds for path-finding algorithms as they can provide bench marking and the ability to create and control their own environments[@HH2022]. However, this isn't their main purpose and game engines can be difficult to use, especially something like the unreal developed by epic games. This leads to an issue where a tool isn't powerful enough to be used as a proper way to analyze something or it has a major learning curve on how to create a map and implement code because of it having a broader purpose and not being focused on analyzing path-finding algorithms.

### Multimedia API

There are also APIs such as SDL/SDL2/SDl3 and something like Microsoft DirectX which are libraries built for interacting with a computer’s hardware to display images, create windows, play sound and track inputs. These are often used to make simple and high-performance games directly while also often being used as an important component for more complex and powerful game engines[@SDLSITE].

## Motivation

So why do you even make something like this and why is it important? When developing or trying to create a modified version of an existing algorithm i.e. A* developers and researchers often use video games as a test bed and their engines to implement the algorithm and test its performance. This can result in a steep learning curve in understanding the engine and doesn't normally have extensive benchmarking built into it and isn't focused solely on the algorithm itself. While game engines do provide a great environment to test path-finding algorithms they aren't solely built for it so a lot of the analysis must be done by the developers themselves using known techniques. My program aims to be easy to use and give extensive data on the performance of these algorithms by not testing them on a singular map but by giving it multiple different circumstance's tracking what those differences are and how it performs to help come up with how this an algorithm succeeds and its shortcomings and if it's a good fit for the problem you're trying to solve whether it's finding routes on a real life map or trying to control AI in games to have affective path-finding these require different types algorithms with tradeoffs and my tool hopes to make this process easier.

Having a tool that is easy to use, and in-depth benchmarking would be very useful as it cuts out a lot of the learning curve for more complex game engines while also providing more in-depth analysis of these algorithms. Benchmarking can help determine if an algorithm you've created or you're wanting to implement is right for your circumstance. For example if I use something like A* while A* is very accurate and fast for how accurate it is, It's not great for a path that changes on the fly so if you want to implement in a more dynamic environment there is a lot of pre-computation time required which is the issue that is often found in 3D video-games and the their use of navigation meshes requiring hours of pre-computation per map before the NPCs or AI is effective at navigating the map. This type of thing isn't an issue for larger companies and is useful in many of these circumstances as once it's computed you don't need to worry about it again. This does however increase file size and may not be Ideal for a smaller project or simpler project.

In-depth benchmarking is essential for determining whether a specific algorithm is appropriate for a particular scenario. For example, A* is highly accurate and efficient in static environments, but its performance degrades in dynamic environments where obstacles or goals change over time. In these cases, A* often relies on extensive precomputation, such as the generation of navigation meshes (NavMeshes), which requires memory and computational resources in three or two dimensional environments [@BRANDSANDYTHESIS]. Large commercial game studios can accommodate these costs and once computed have been shown to decrease the cost of pathfinding, but smaller projects or procedurally generated worlds may find this approach impractical due to memory constraints, loading-time limitations, or file-size restrictions as NavMeshes can take up a large amount of memory and don't perform as well in dynamic environments.

For example, Terraria, a very popular game made by Re-Logic, doesn't use navigation meshes or a pre-computed map. One reason for this is that it can't, as Terraria generates a unique world upon first loading in meaning if it were to try and create a navigation map or probabilistic map beforehand it could increase loading and performance do to the environment being constantly changing as result of player and AI actions and the layout of the map being unknown making a Navmesh impractical. So instead different enemies have different defined behaviors one of the most commonly used behaviors is referred to as the fighterAI,  which allows entities to follow the player and navigate basic terrain features[@TERWIKI:001]. This works great for the majority of enemies but when it comes more complex entities, such as bosses, are often programmed to ignore obstacles entirely, enabling continuous pursuit without requiring costly path computation[@TERWIKI:002].

Every path-finding algorithm has intrinsic trade-offs, a tool that enables users to construct their own maps, implement custom pathfinding methods, and observe algorithmic performance. Such a tool helps users make decisions on what algorithms to use while also gleaming a better understanding of these algorithms and how much resources they take, How accurate they are in terms of finding the shortest possible path. How their abilities are affected when in a dynamic environment or the issues and what kind of environmental structures influence performance.

Additionally, many developers and organizations may choose not to rely on fully featured game engines. They may instead develop custom engines or work with lightweight multimedia frameworks such as SDL as used in Pathmaker or toolkits such as Microsoft XNA. These frameworks provide rendering and input-handling capabilities but do not include comprehensive environment-creation tools or built-in pathfinding systems. As a result users must construct their own testing environments from the ground up. If they later transition to a full engine such as Unreal Engine, significant reimplementation is required, making algorithmic testing undesirable in some instances. A tool like Pathmaker would make it easier to make these decision without having to fully integrate a testing framework within the software the user is using.

Having a dedicated and easy-to-use tool reduces these obstacles by enabling fast environment setup and direct algorithm integration without the need to build or learn an entire engine framework. While such a tool does not replicate all features of a full game engine, it offers a practical and efficient method for preliminary analysis, allowing researchers and/or developers to make informed decisions about algorithm selection before attempting integration into a larger system.

## Goals of the Project

The goal of this project is to make a functional and robust tool that as said before allows for the creation of 2D grid-based maps. The ability to modify and save maps is Important for users to accurately represent the environment they want to use a path-finding algorithm in.

I want this project to also be able to aid in the analysis of algorithms in general and just decide when they should be used. So, the ability to randomly generate maps and running a series of benchmarking aims to achieve this goal. This goal is also why allowing the implementation of modified or new algorithms is important as only allowing well known algorithms can provide little value as a large amount of information is already known about how they behave in different scenarios and there isn't much that could be gleamed from this tool alone that wasn't already known.

Overall, this tool should give an easy to understand and in-depth analysis of a path-finding algorithm to aid in understanding and general analysis and research as well as helping to decide if the algorithm is the right fit for the situation someone might want to implement it in.

While a lot of these functions can already be achieved to some extent with other tools such as game engines as mentioned before, they are not specifically designed with pathfinding solely in mind. While they're a suitable test bed there's an additional learning curve in how to design and create maps and how to implement a program within the engines. This learning curve varies depending on the engine as something like Godot is inherently simpler than Unreal but there still is a large amount of functionality and complexity in the map creation. Along with implementing a program can lead to a confusing experience. 

## Ethical Implications and Assumptions

### Accuracy

It's important for this tool to work properly and accurately. If it doesn't provide accurate information with tested and researched methods, it runs the risk of giving untrustworthy data and results. This tool’s whole purpose relies on accurate results and if it's not accurate it fails its purpose, so it needs to be thoroughly tested and needs to use well researched methods when it comes to analyzing path-finding algorithms.

### Transparency

Since this is a tool made by one person and not a professional product or application it's important to acknowledge that this tool isn't going to be perfect it's going to have issues. There may be some mistakes when it comes to analysis, they may have performance issues. There may be parts of the tool that are flakier than others so being transparent about what the issues are and where bugs are important for keeping this tool reliable and informing people on how it should be used.

### Future Development

As this tool uses SDL2 and older version of SDL the development of this tool could be stunted in the future if it is not transitioned to SDL3 as access to SDL2 may be limited in the future making it difficult to work on the tool without already having the required libraries to develop and run the program.

### Security

There is also the issue of having it as a downloadable binary this could pose a security risk to people computers the download needs to be secure, or it can run the risk of installing malware. If it's on GitHub if GitHub ever has a security breach, then the tool could be compromised and could be modified without permission. This is a cause for concern but given the circumstances there's little work around for the situation. I wouldn't be able to make something more secure than GitHub downloads by myself.

### Accessibility

Since this tool is an application, it needs accessibility options for those who are visually impaired or mechanically impaired so having keyboard shortcuts, font setting to change font sizes and font style is important to ensure as many people can use the tool as possible. Having the option for color-blind colors is also a consideration but the goal of the tool is to mostly use neutral colors to try and limit the amount of changes the tool would need.


