# Introduction

This project aims to create a tool that easy to use and understand to help in the development and analysis of path finding algorithms. The tool has the ability to create,edit, generate and save maps. This is so the user can create there own maps for the path-finding algorithm and generate different scenarios based on that baseline map given. The idea is to be able to test the algorithm for a persons specific use case and then give different situations and see how it performs and where it may be lacking.
The program analyzes the results through benchmarking by tracking things like starting distance from goal, steps taken to reach goal, steps to get a result and memory usage. It will then store this information and display it for analysis. The hope for this project is that it makes testing and analyzing path-finding algorithms easier and to have a dedicated tool to that purpose instead of using a secondary feature of something like a game engine or having to make you're own testing environment.

With all that said what actually is path-finding? Path-finding is a program designed to find a path between two points or multiple points facets of it are used in many different industries such as in GPS like google maps or ways, In video-games to control the movement of NPCs(non playable character ) and objects, There even used in AI to help it make decisions in many different circumstance find the path of least resistance to achieving it's goal whatever it may be.

When Evaluating path-finding algorithm the algorithm you choose is important but just is important is how the algorithm gives information in things with a 3D environment like video-games something like a NavMesh is used. (Talk About nav meshes). This tool is focused and grid based path-finding so the information is represented as a graphs with obstacles, the starting point and the goal all being represented as a coordinate. In a grid based system there is no differing values for move so in something like google maps it may pick a route based on fuel consumed and not overall distance as it may have less distance but if it's more uphill you're car uses more fuel making it not fuel efficient but less of a distance. Thing's like A* and Djikstra and a lot of the more fundamental algorithms can still be used in this situation the states or weight of an action just need to be evaluated differently and the way information is provided is different.

There are also weighted grids which have different values depending on a coordinate. In a normal grid moving one space over can simply be represented by 1 no matter where it is on the grid. Weighted grids differ as moving one space over may have a cost of 2 or 3 or any number depending on how the weighted grid is set up. There are also situations where theres a dynamic environment where the map is always changing or the location the algorithm is trying to navigate is always changing think of something like self driving car or a Roomba. This things normally have a set path they follow but need to to be able to react to changes in the environment so it doesn't crash or in the a more minor case a Roomba runs into someone leg. In this situation just using one algorithm doesn't work it needs to be able to react to a changing environment. Then there's also situations with multiple agents where they need to avoid colliding with each other but aim to achieve the same goal.

Another way information can be represent is a probabilistic map. Where a map is generated by take multiple different nodes placing it someone where on the map. It then will check if the node is within an obstacle space if it isn't it keeps and attempts to connect to other viable nodes. It does this by finding a path through another pathfinding algorithm like Djikstra or A* and checks if that line collides with a Obstacle at any point. It does this multiple times until it has a comprehensive map of nodes with paths connecting each one to each other without colliding with an obstacle. This allows every possible movements path to already been calculated and you use another algorithm called a path planner to know which nodes to go to to get to a specified destination.

The type of algorithm you want to use and whether you want to use a navigation mesh or a probabilistic map, or simply to a straight algorithm depends on the need and resources available for the project. A nav mesh represents the walkable areas as polygons and connects these areas together using A* to help create paths calculating much smaller paths in subsections of the map instead trying to calculate the whole map at once. Probabilistic maps are very similar but instead of being represented by polygons it's individual node and each node tries to connect to each other and tries to find paths without colliding with each other

This tool will only be working with a 2D grid. One because it's the easiest to implement and for the purposes of analyzing a path-finding algorithm. Probabilistic Maps and Nav-meshes are generated from path-finding algorithms and stored for later in a static environment like a video-game map.

## Motivation

So why even make something like this and why is it important? When developing or trying to create a modified version of an existing algorithm i.e. A* developers and researchers often use video-games as a test bed and there engines to implement the algorithm and test it's performance. This can result in a steep learning curve in understanding the engine and doesn't normally have extensive benchmarking built in to it and isn't focused solely on the algorithm itself. While game engines do provide a great environment to test path-finding algorithms they aren't solely built for it so a lot of the analysis has to be done by the developer themselves using known techniques. My program aims to be easy to use and give extensive data on the performance of these algorithms by not testing them on a singular map but by giving it multiple different circumstance's tracking what those differences are and how it performs to help come up with how this an algorithm succeeds and it's it's shortcomings and if it's a good fit for the problem you're trying to solve whether it's finding routes on a real life map or trying to control AI in games to have affective path-finding these require different types algorithms with trade offs and my tool hopes to make this process easier.

Having a tool that is easy to use and in depth benchmarking would be very useful as it cuts out a lot of the learning curve for more complex game engines while also providing more in-depth analysis of these algorithms. Benchmarking can help determine is an algorithm you've created or you're wanting to implement is right for your circumstance. For example if I use something like A* while A* is very accurate and fast for how accurate it is, It's not great for a path that changes on the fly so if you want to implement in a more dynamic environment there is a lot of pre-computation time required which is the issue that is often found in 3D video-games and the there use of navigation meshes requiring hours of pre-computation per map before the NPCs or AI is effective at navigating the map. This type of thing isn't an issue for larger companies and is useful in many of these circumstances as once it's computed you don't need to worry about it again. This does however increase file size and may not be Ideal for a smaller project or simpler project. 

For example Terraria a very popular game made by a small Studio doesn't use navigation meshes or a pre-computed pathing. One reason for this is that it can't Terraria generates a unique world when you play meaning it can't compute pathing before hand. Something like minecraft has a Similar issue. So how do these games solve this issue. They often use A* in a limited case they severely limit it's range/depth so it doesn't take to long to take an action. This changes when fighting a boss in these games as they don't want it to be easy to lose the focus of the boss. But with the implementation of A* in these games enemies don't have dynamic behavior and don't fully understand the environment there in making it very easy to trap them as they don't react to changes in the environment. This is fine for normal NPC's but for something like a Boss is an undesirable. Terraria solves this by making all of it's bosses ignore terrain and are flying creatures so they can often just phase through obstacles and just go straight towards the player. Minecraft takes a Similar approach with the EnderDragon boss as it can also phase through obstacles and terrain although it doesn't normally go straight towards the player like bosses in Terraria.

Every path-finding algorithm has pro's and con's and is useful in different situations and deciding which is best for you're situation or using multiple and changing which one is used depending on the situation is very important. Having a tool where you can make you're own maps admittedly in a limited context and being able Implement one of these algorithms or create a modified version you're self well help you make a decision on this without and also gleam a better understanding of these algorithms and how much resources they take, How accurate they are in terms of finding the shortest possible path. How there abilities are effected when in a dynamic environment or the issues and what kind of environments different algorithms thrive in.

There is also the fact that while a lot of individuals and companies may used a pre-made fully fledged out game engine they may decide to make there own engine or use something like Microsoft XNA or SDL. Which are primarily for making games but they don't have the fool features of a game engine and a built in work environment there mostly just tools that help with displays and game logic. So they have to set up there own testing environment for path-finding and if they wanted to use an Engine like unreal features they would have to set up everything again in that engine which is not worth doing. A tool that is easy to use and can easily set up and environment and implementing a algorithm will help make these decisions earlier on without having to fully set up and environment before hand. While it won't give as good of an understanding as running it in the actual game someone is creating it can give an idea for the direction a developer may wan't to take.

## Current State of the Art

Currently there are things like path-finding visualizers that you can find online these are mostly for education purposes and given a visualization on how these algorithms actually work and find the pat. These often don't have any benchmarking capability and if they do it's simply tracking time to find path. They are also often very finnicky and unresponsive but that is a more of a result as a lot of them just being fun side projects of someones and not being a professionally made tool. 

Game Engines like Unreal, Godot, Unity and others are often used as testbeds for path-finding algorithms as they can provide bench marking and the ability to create and control there own environments. However this isn't there main purpose and game engines can be difficult to use especially something like unreal. This leads to an issue where a tool isn't powerful enough to be used as a proper way to analyze something or it's has a major learning curve on how to create a map and implement code as a result of it having a broader purpose and not being focus on analyzing path-finding algorithms.

## Goals of the Project

The goal of this project is to make a functional and robust tool that as said before allows for the creation of 2D grid based maps. The abilities to modify and save maps is Important in order for users to accurately represent the environment they want to use a path-finding algorithm in.

I want this project to also be able to aid in the analysis of algorithms in general and just deciding when they should be used. So the ability to randomly generate maps and running a series of benchmarking aims to achieve this goal. This goal is also why allowing the implementation of modified or new algorithms is important as only allowing well known algorithms can provide little value as a large amount information is already known about how they behave in different scenarios and there isn't much that could be gleamed from this tool alone that wasn't already known.

Overall this tool should give an easy to understand and in-depth analysis of a path-finding algorithm to aid in understanding and general analysis and research as well as helping to decide if the algorithm is a right fit for the situation someone might want to implement it in.

While a lot of these functions can already be achieve to some extent with other tools such as game engines as mentioned before they are not specifically designed with path-finding solely in mind. While they're a suitable test bed there's an additional learning curve in how to design and create maps and how to actually implement a program with in the engines. This learning curve varies depending on the engine as something like Godot is inherently simpler then Unreal but there still is a large amount of functionality and complexity in the map creation. Along with actually implementing a program can lead to a confusing experience. 


## Ethical Implications


### Accuracy

It's important for this tool to work properly and accurately. If it doesn't provide accurate information with tested and researched methods it runs the risk of given untrustworthy data and results. This tool whole purpose relies on accurate results and if it's not accurate it fails it's purpose so it needs to be thoroughly tested and needs to use well researched methods when it comes to analyzing path-finding algorithms.

### Transparency

Since this is a tool made by one person and not a professional product or application it's important to acknowledge that this tool isn't going to be perfect it's going to have issues. There may be some mistakes when it comes to analysis it may have performance issues. There may be parts of the tool that are more flaky then others so being transparent about what the issues are and where bugs are important for keeping this tool reliable and informing people on how it should be used.

### Security

There is also the issue of having it as a downloadable binary this could pose a security risk to people computers the download needs to be secure or it can run the risk of installing malware. If it's on github if github ever has a security breach then the tool could be compromised and could be modified without permission. This is a cause for concern but given the circumstance there's little work around for the situation. I wouldn't be able to make something more secure than github downloads by myself.


### Accessibility

Since this tool is an application it needs to accessibility options for those who are visually impaired or mechanically impaired so having keyboard shortcuts, font setting to change font sizes and font style is important to ensure as many people are able to use the tool as possible. Having the option for color-blind colors is also a consideration but the goal of the tool is to mostly use neutral colors to try and limit the amount of changes the tool would need.
